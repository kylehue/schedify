(function(){"use strict";function w(s,e,t,i){if(s>e||t>i)throw new RangeError("Lower bound must be less than the higher bound.");return s<i&&t<e}const L=(s,e)=>{if(s===e)return 0;if(typeof s=="string"&&typeof e=="string")return s.localeCompare(e);if(typeof s=="number"&&typeof e=="number")return s-e;throw new Error("Unsupported type or mixed types in default comparator")};var M=Object.defineProperty,j=(s,e,t)=>e in s?M(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,d=(s,e,t)=>j(s,typeof e!="symbol"?e+"":e,t);let z=class b{constructor(e){d(this,"_root"),d(this,"_size",0),d(this,"_comparator",L),e&&(this._comparator=e)}insert(e){const t=new y(e),i=r=>r===void 0?(r=t,r):(this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right())),r.balance());this._size++,this._root=i(this._root)}delete(e){let t;const i=r=>{if(r!==void 0){if(e===r.value()){this._size--;let n=r.left(),o=r.right();if(n&&o){let u=o,l;for(;u.left();)l=u,u=u.left();u.setLeft(n),u!==o&&u.setRight(o),l&&l.setLeft(void 0),t=u}else n&&!o?t=n:!n&&o?t=o:t=void 0;return r.setLeft(void 0),r.setRight(void 0),t==null?void 0:t.balance()}else this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right()));return r.balance()}};return this._root=i(this._root),t}filter(e){let t=this.toArray(),i=[];for(let r=t.length-1;r>=0;r--){let n=t[r];e(n)||(this.delete(n),i.push(n))}return i}clear(){this._root=void 0,this._size=0}clone(){const e=i=>{if(i===void 0)return;let r=new y(i.value());return r.setLeft(e(i.left())),r.setRight(e(i.right())),r.setHeight(i.height()),r},t=new b(this._comparator);return t._root=e(this._root),t._size=this._size,t}toArray(){return[...this.values()]}min(){if(this._root===void 0)return;let e=this._root;for(;e.left()!==void 0;)e=e.left();return e.value()}max(){if(this._root===void 0)return;let e=this._root;for(;e.right()!==void 0;)e=e.right();return e.value()}size(){return this._size}isEmpty(){return this._size===0}height(){var e;return((e=this._root)==null?void 0:e.height())??0}root(){if(this._root)return this._root}*values(){function*e(t){t!==void 0&&(yield*e(t.left()),yield t.value(),yield*e(t.right()))}yield*e(this._root)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){const i=new b(t);return e.forEach(r=>i.insert(r)),i}static fromSortedArray(e,t){const i=new b(t),r=(n,o)=>{if(n>o)return;let u=n+o>>1,l=new y(e[u]);return l.setLeft(r(n,u-1)),l.setRight(r(u+1,o)),l.updateHeight(),l};return i._root=r(0,e.length-1),i._size=e.length,i}},y=class{constructor(e){d(this,"_value"),d(this,"_left"),d(this,"_right"),d(this,"_height",1),this._value=e}left(){return this._left}right(){return this._right}value(){return this._value}height(){return this._height}setLeft(e){this._left=e}setRight(e){this._right=e}setHeight(e){this._height=e}updateHeight(){var e,t;this._height=1+Math.max(((e=this._left)==null?void 0:e._height)??0,((t=this._right)==null?void 0:t._height)??0)}rotateLeft(){let e=this._right;return e===void 0?this:(this._right=e._left,e._left=this,this.updateHeight(),e.updateHeight(),e)}rotateRight(){let e=this._left;return e===void 0?this:(this._left=e._right,e._right=this,this.updateHeight(),e.updateHeight(),e)}computeBalanceFactor(){var e,t;let i=((e=this._left)==null?void 0:e._height)??0,r=((t=this._right)==null?void 0:t._height)??0;return i-r}balance(){this.updateHeight();let e=this.computeBalanceFactor();if(e>1){let t=this.left();return t!==void 0&&t.computeBalanceFactor()<0&&this.setLeft(t.rotateLeft()),this.rotateRight()}else if(e<-1){let t=this.right();return t!==void 0&&t.computeBalanceFactor()>0&&this.setRight(t.rotateRight()),this.rotateLeft()}return this}};var S=Object.defineProperty,T=(s,e,t)=>e in s?S(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,p=(s,e,t)=>T(s,typeof e!="symbol"?e+"":e,t);class m{constructor(e){p(this,"_rangeMapper"),p(this,"_tree",new z((t,i)=>t.lowerBound-i.lowerBound)),this._rangeMapper=e}insert(e){let[t,i]=this._rangeMapper(e);if(t>i)throw new RangeError("Lower bound must be less than the higher bound.");const r=new x(t,i,i,e);this._tree.insert(r),this._recomputeMaxUpperBound(e)}delete(e){for(let{node:t,parent:i}of this._traverseTo(e)){if(t.value().data!==e)continue;let r=this._tree.delete(t.value())??i;r!==void 0&&this._recomputeMaxUpperBound(r.value().data)}}filter(e){let t=[];function i(n){n!==void 0&&(t.push(n.value()),i(n.left()),i(n.right()))}i(this._tree.root());let r=[];for(let n of t)e(n.data)||(this.delete(n.data),r.push(n.data));return r}deleteInRange(e,t,i){return this.filter(r=>{let[n,o]=this._rangeMapper(r);return!(i&&(n===t||o===e)||w(e,t,n,o))})}query(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");return[...this.rangeQuery(e,t,i)]}hasOverlap(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");for(let r of this.rangeQuery(e,t,i))return!0;return!1}clear(){this._tree.clear()}size(){return this._tree.size()}isEmpty(){return this._tree.isEmpty()}clone(){const e=new m(this._rangeMapper);return e._tree=this._tree.clone(),e}*rangeQuery(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");function*r(n){if(n===void 0)return;const{lowerBound:o,upperBound:u,data:l}=n.value();(i&&(o===t||u===e)||w(e,t,o,u))&&(yield l);let a=n.left();a&&a.value().maxUpperBound>=e&&(yield*r(a)),yield*r(n.right())}yield*r(this._tree.root())}*values(){yield*this.rangeQuery(-1/0,1/0)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){let i=new m(t);return e.forEach(r=>i.insert(r)),i}_recomputeMaxUpperBound(e){var t,i;for(let{node:r}of this._traverseTo(e)){let n=r.value().upperBound;r.value().maxUpperBound=Math.max(n,((t=r.left())==null?void 0:t.value().maxUpperBound)??n,((i=r.right())==null?void 0:i.value().maxUpperBound)??n)}}*_traverseTo(e){let t=this._rangeMapper(e)[0];function*i(r,n){if(r===void 0)return;let o=r.value().lowerBound;if(r.value().data===e){yield{node:r,parent:n};return}t<o?yield*i(r.left(),r):yield*i(r.right(),r),yield{node:r,parent:n}}yield*i(this._tree.root(),void 0)}}class x{constructor(e,t,i,r){p(this,"data"),p(this,"lowerBound"),p(this,"upperBound"),p(this,"maxUpperBound"),this.data=r,this.lowerBound=e,this.upperBound=t,this.maxUpperBound=i}}function f(){return new m(s=>circleTimeRange(timeToDecimal(s.from),timeToDecimal(s.to)))}function B(s,e){return`${s},${e}`}function A(s){const e=[],t=new Set,i=Array.from(s.values()).filter(l=>l.isEnabled);if(!i.length)return e;const r={};for(const l of i)r[l.code]=Array.from(l.sections.values()).filter(a=>a.isEnabled);const n={};for(const l in r)for(const a of r[l]){const g=B(l,a.code);n[g]=Array.from(a.timeslots.values()).filter(h=>h.isEnabled)}const o={mon:f(),tue:f(),wed:f(),thu:f(),fri:f(),sat:f(),sun:f()};function u(l=[],a=0){if(a===i.length){e.push(l.slice());return}for(let g=a;g<i.length;g++){const h=i[g];if(t.has(h.code))continue;const H=r[h.code];for(const v of H){let R=!1;const D=n[B(h.code,v.code)];for(const c of D){let[_,F]=circleTimeRange(timeToDecimal(c.from),timeToDecimal(c.to));if(o[c.day].hasOverlap(_,F)){R=!0;break}}if(R)continue;l.push({subject:h,section:v}),t.add(h.code);let E=[];for(let[c,_]of v.timeslots)o[_.day].insert(_),E.push(_);u(l,a+1),l.pop(),t.delete(h.code);for(let c of E)o[c.day].delete(c)}}}return u(),e}function U(s){let e=new Map;for(let t of s){let i={code:t.c,isEnabled:t.e,description:t.d,sections:new Map};for(let r of t.s){let n={code:r.c,isEnabled:r.e,description:r.d,timeslots:new Map};for(let o of r.t){let u={day:o.d,from:o.f,to:o.t,id:o.i,isEnabled:o.e};n.timeslots.set(u.id,u)}i.sections.set(n.code,n)}e.set(i.code,i)}return e}self.onmessage=s=>{let e=U(s.data);const t=A(e);self.postMessage(t)}})();
