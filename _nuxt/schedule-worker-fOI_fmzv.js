(function(){"use strict";function w(s,e,t,i){if(s>e||t>i)throw new RangeError("Lower bound must be less than the higher bound.");return s<i&&t<e}const E=(s,e)=>{if(s===e)return 0;if(typeof s=="string"&&typeof e=="string")return s.localeCompare(e);if(typeof s=="number"&&typeof e=="number")return s-e;throw new Error("Unsupported type or mixed types in default comparator")};var M=Object.defineProperty,z=(s,e,t)=>e in s?M(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,f=(s,e,t)=>z(s,typeof e!="symbol"?e+"":e,t);let T=class y{constructor(e){f(this,"_root"),f(this,"_size",0),f(this,"_comparator",E),e&&(this._comparator=e)}insert(e){const t=new v(e),i=r=>r===void 0?(r=t,r):(this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right())),r.balance());this._size++,this._root=i(this._root)}delete(e){let t;const i=r=>{if(r!==void 0){if(e===r.value()){this._size--;let n=r.left(),o=r.right();if(n&&o){let l=o,u;for(;l.left();)u=l,l=l.left();l.setLeft(n),l!==o&&l.setRight(o),u&&u.setLeft(void 0),t=l}else n&&!o?t=n:!n&&o?t=o:t=void 0;return r.setLeft(void 0),r.setRight(void 0),t==null?void 0:t.balance()}else this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right()));return r.balance()}};return this._root=i(this._root),t}filter(e){let t=this.toArray(),i=[];for(let r=t.length-1;r>=0;r--){let n=t[r];e(n)||(this.delete(n),i.push(n))}return i}clear(){this._root=void 0,this._size=0}clone(){const e=i=>{if(i===void 0)return;let r=new v(i.value());return r.setLeft(e(i.left())),r.setRight(e(i.right())),r.setHeight(i.height()),r},t=new y(this._comparator);return t._root=e(this._root),t._size=this._size,t}toArray(){return[...this.values()]}min(){if(this._root===void 0)return;let e=this._root;for(;e.left()!==void 0;)e=e.left();return e.value()}max(){if(this._root===void 0)return;let e=this._root;for(;e.right()!==void 0;)e=e.right();return e.value()}size(){return this._size}isEmpty(){return this._size===0}height(){var e;return((e=this._root)==null?void 0:e.height())??0}root(){if(this._root)return this._root}*values(){function*e(t){t!==void 0&&(yield*e(t.left()),yield t.value(),yield*e(t.right()))}yield*e(this._root)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){const i=new y(t);return e.forEach(r=>i.insert(r)),i}static fromSortedArray(e,t){const i=new y(t),r=(n,o)=>{if(n>o)return;let l=n+o>>1,u=new v(e[l]);return u.setLeft(r(n,l-1)),u.setRight(r(l+1,o)),u.updateHeight(),u};return i._root=r(0,e.length-1),i._size=e.length,i}},v=class{constructor(e){f(this,"_value"),f(this,"_left"),f(this,"_right"),f(this,"_height",1),this._value=e}left(){return this._left}right(){return this._right}value(){return this._value}height(){return this._height}setLeft(e){this._left=e}setRight(e){this._right=e}setHeight(e){this._height=e}updateHeight(){var e,t;this._height=1+Math.max(((e=this._left)==null?void 0:e._height)??0,((t=this._right)==null?void 0:t._height)??0)}rotateLeft(){let e=this._right;return e===void 0?this:(this._right=e._left,e._left=this,this.updateHeight(),e.updateHeight(),e)}rotateRight(){let e=this._left;return e===void 0?this:(this._left=e._right,e._right=this,this.updateHeight(),e.updateHeight(),e)}computeBalanceFactor(){var e,t;let i=((e=this._left)==null?void 0:e._height)??0,r=((t=this._right)==null?void 0:t._height)??0;return i-r}balance(){this.updateHeight();let e=this.computeBalanceFactor();if(e>1){let t=this.left();return t!==void 0&&t.computeBalanceFactor()<0&&this.setLeft(t.rotateLeft()),this.rotateRight()}else if(e<-1){let t=this.right();return t!==void 0&&t.computeBalanceFactor()>0&&this.setRight(t.rotateRight()),this.rotateLeft()}return this}};var j=Object.defineProperty,S=(s,e,t)=>e in s?j(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,g=(s,e,t)=>S(s,typeof e!="symbol"?e+"":e,t);class m{constructor(e){g(this,"_rangeMapper"),g(this,"_tree",new T((t,i)=>t.lowerBound-i.lowerBound)),this._rangeMapper=e}insert(e){let[t,i]=this._rangeMapper(e);if(t>i)throw new RangeError("Lower bound must be less than the higher bound.");const r=new x(t,i,i,e);this._tree.insert(r),this._recomputeMaxUpperBound(e)}delete(e){for(let{node:t,parent:i}of this._traverseTo(e)){if(t.value().data!==e)continue;let r=this._tree.delete(t.value())??i;r!==void 0&&this._recomputeMaxUpperBound(r.value().data)}}filter(e){let t=[];function i(n){n!==void 0&&(t.push(n.value()),i(n.left()),i(n.right()))}i(this._tree.root());let r=[];for(let n of t)e(n.data)||(this.delete(n.data),r.push(n.data));return r}deleteInRange(e,t,i){return this.filter(r=>{let[n,o]=this._rangeMapper(r);return!(i&&(n===t||o===e)||w(e,t,n,o))})}query(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");return[...this.rangeQuery(e,t,i)]}hasOverlap(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");for(let r of this.rangeQuery(e,t,i))return!0;return!1}clear(){this._tree.clear()}size(){return this._tree.size()}isEmpty(){return this._tree.isEmpty()}clone(){const e=new m(this._rangeMapper);return e._tree=this._tree.clone(),e}*rangeQuery(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");function*r(n){if(n===void 0)return;const{lowerBound:o,upperBound:l,data:u}=n.value();(i&&(o===t||l===e)||w(e,t,o,l))&&(yield u);let a=n.left();a&&a.value().maxUpperBound>=e&&(yield*r(a)),yield*r(n.right())}yield*r(this._tree.root())}*values(){yield*this.rangeQuery(-1/0,1/0)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){let i=new m(t);return e.forEach(r=>i.insert(r)),i}_recomputeMaxUpperBound(e){var t,i;for(let{node:r}of this._traverseTo(e)){let n=r.value().upperBound;r.value().maxUpperBound=Math.max(n,((t=r.left())==null?void 0:t.value().maxUpperBound)??n,((i=r.right())==null?void 0:i.value().maxUpperBound)??n)}}*_traverseTo(e){let t=this._rangeMapper(e)[0];function*i(r,n){if(r===void 0)return;let o=r.value().lowerBound;if(r.value().data===e){yield{node:r,parent:n};return}t<o?yield*i(r.left(),r):yield*i(r.right(),r),yield{node:r,parent:n}}yield*i(this._tree.root(),void 0)}}class x{constructor(e,t,i,r){g(this,"data"),g(this,"lowerBound"),g(this,"upperBound"),g(this,"maxUpperBound"),this.data=r,this.lowerBound=e,this.upperBound=t,this.maxUpperBound=i}}function d(){return new m(s=>circleTimeRange(timeToDecimal(s.from),timeToDecimal(s.to)))}function B(s,e){return`${s},${e}`}function A(s){const e=[],t=new Set,i=Array.from(s.values()).filter(u=>u.isEnabled);if(!i.length)return e;const r={};for(const u of i)r[u.code]=Array.from(u.sections.values()).filter(a=>a.isEnabled);const n={};for(const u in r)for(const a of r[u]){const p=B(u,a.code);n[p]=Array.from(a.timeslots.values()).filter(h=>h.isEnabled)}const o={mon:d(),tue:d(),wed:d(),thu:d(),fri:d(),sat:d(),sun:d()};function l(u=[],a=0){if(a===i.length){e.push(u.slice());return}for(let p=a;p<i.length;p++){const h=i[p];if(t.has(h.code))continue;const U=r[h.code];for(const b of U){let R=!1;const H=n[B(h.code,b.code)];for(const c of H){let[_,D]=circleTimeRange(timeToDecimal(c.from),timeToDecimal(c.to));if(o[c.day].hasOverlap(_,D)){R=!0;break}}if(R)continue;u.push({subject:h,section:b}),t.add(h.code);let L=[];for(let[c,_]of b.timeslots)o[_.day].insert(_),L.push(_);l(u,a+1),u.pop(),t.delete(h.code);for(let c of L)o[c.day].delete(c)}}}return l(),e}self.onmessage=s=>{let e=deserializeSubjects(s.data);const t=A(e);self.postMessage(t)}})();
