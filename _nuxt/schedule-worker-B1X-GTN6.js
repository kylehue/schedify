(function(){"use strict";function B(s,e,t,i){if(s>e||t>i)throw new RangeError("Lower bound must be less than the higher bound.");return s<i&&t<e}const S=(s,e)=>{if(s===e)return 0;if(typeof s=="string"&&typeof e=="string")return s.localeCompare(e);if(typeof s=="number"&&typeof e=="number")return s-e;throw new Error("Unsupported type or mixed types in default comparator")};var x=Object.defineProperty,A=(s,e,t)=>e in s?x(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,d=(s,e,t)=>A(s,typeof e!="symbol"?e+"":e,t);let T=class y{constructor(e){d(this,"_root"),d(this,"_size",0),d(this,"_comparator",S),e&&(this._comparator=e)}insert(e){const t=new v(e),i=r=>r===void 0?(r=t,r):(this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right())),r.balance());this._size++,this._root=i(this._root)}delete(e){let t;const i=r=>{if(r!==void 0){if(e===r.value()){this._size--;let n=r.left(),o=r.right();if(n&&o){let l=o,u;for(;l.left();)u=l,l=l.left();l.setLeft(n),l!==o&&l.setRight(o),u&&u.setLeft(void 0),t=l}else n&&!o?t=n:!n&&o?t=o:t=void 0;return r.setLeft(void 0),r.setRight(void 0),t==null?void 0:t.balance()}else this._comparator(e,r.value())<0?r.setLeft(i(r.left())):r.setRight(i(r.right()));return r.balance()}};return this._root=i(this._root),t}filter(e){let t=this.toArray(),i=[];for(let r=t.length-1;r>=0;r--){let n=t[r];e(n)||(this.delete(n),i.push(n))}return i}clear(){this._root=void 0,this._size=0}clone(){const e=i=>{if(i===void 0)return;let r=new v(i.value());return r.setLeft(e(i.left())),r.setRight(e(i.right())),r.setHeight(i.height()),r},t=new y(this._comparator);return t._root=e(this._root),t._size=this._size,t}toArray(){return[...this.values()]}min(){if(this._root===void 0)return;let e=this._root;for(;e.left()!==void 0;)e=e.left();return e.value()}max(){if(this._root===void 0)return;let e=this._root;for(;e.right()!==void 0;)e=e.right();return e.value()}size(){return this._size}isEmpty(){return this._size===0}height(){var e;return((e=this._root)==null?void 0:e.height())??0}root(){if(this._root)return this._root}*values(){function*e(t){t!==void 0&&(yield*e(t.left()),yield t.value(),yield*e(t.right()))}yield*e(this._root)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){const i=new y(t);return e.forEach(r=>i.insert(r)),i}static fromSortedArray(e,t){const i=new y(t),r=(n,o)=>{if(n>o)return;let l=n+o>>1,u=new v(e[l]);return u.setLeft(r(n,l-1)),u.setRight(r(l+1,o)),u.updateHeight(),u};return i._root=r(0,e.length-1),i._size=e.length,i}},v=class{constructor(e){d(this,"_value"),d(this,"_left"),d(this,"_right"),d(this,"_height",1),this._value=e}left(){return this._left}right(){return this._right}value(){return this._value}height(){return this._height}setLeft(e){this._left=e}setRight(e){this._right=e}setHeight(e){this._height=e}updateHeight(){var e,t;this._height=1+Math.max(((e=this._left)==null?void 0:e._height)??0,((t=this._right)==null?void 0:t._height)??0)}rotateLeft(){let e=this._right;return e===void 0?this:(this._right=e._left,e._left=this,this.updateHeight(),e.updateHeight(),e)}rotateRight(){let e=this._left;return e===void 0?this:(this._left=e._right,e._right=this,this.updateHeight(),e.updateHeight(),e)}computeBalanceFactor(){var e,t;let i=((e=this._left)==null?void 0:e._height)??0,r=((t=this._right)==null?void 0:t._height)??0;return i-r}balance(){this.updateHeight();let e=this.computeBalanceFactor();if(e>1){let t=this.left();return t!==void 0&&t.computeBalanceFactor()<0&&this.setLeft(t.rotateLeft()),this.rotateRight()}else if(e<-1){let t=this.right();return t!==void 0&&t.computeBalanceFactor()>0&&this.setRight(t.rotateRight()),this.rotateLeft()}return this}};var U=Object.defineProperty,H=(s,e,t)=>e in s?U(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,p=(s,e,t)=>H(s,typeof e!="symbol"?e+"":e,t);class m{constructor(e){p(this,"_rangeMapper"),p(this,"_tree",new T((t,i)=>t.lowerBound-i.lowerBound)),this._rangeMapper=e}insert(e){let[t,i]=this._rangeMapper(e);if(t>i)throw new RangeError("Lower bound must be less than the higher bound.");const r=new P(t,i,i,e);this._tree.insert(r),this._recomputeMaxUpperBound(e)}delete(e){for(let{node:t,parent:i}of this._traverseTo(e)){if(t.value().data!==e)continue;let r=this._tree.delete(t.value())??i;r!==void 0&&this._recomputeMaxUpperBound(r.value().data)}}filter(e){let t=[];function i(n){n!==void 0&&(t.push(n.value()),i(n.left()),i(n.right()))}i(this._tree.root());let r=[];for(let n of t)e(n.data)||(this.delete(n.data),r.push(n.data));return r}deleteInRange(e,t,i){return this.filter(r=>{let[n,o]=this._rangeMapper(r);return!(i&&(n===t||o===e)||B(e,t,n,o))})}query(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");return[...this.rangeQuery(e,t,i)]}hasOverlap(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");for(let r of this.rangeQuery(e,t,i))return!0;return!1}clear(){this._tree.clear()}size(){return this._tree.size()}isEmpty(){return this._tree.isEmpty()}clone(){const e=new m(this._rangeMapper);return e._tree=this._tree.clone(),e}*rangeQuery(e,t,i){if(e>t)throw new RangeError("Lower bound must be less than the higher bound.");function*r(n){if(n===void 0)return;const{lowerBound:o,upperBound:l,data:u}=n.value();(i&&(o===t||l===e)||B(e,t,o,l))&&(yield u);let a=n.left();a&&a.value().maxUpperBound>=e&&(yield*r(a)),yield*r(n.right())}yield*r(this._tree.root())}*values(){yield*this.rangeQuery(-1/0,1/0)}*[Symbol.iterator](){yield*this.values()}static fromArray(e,t){let i=new m(t);return e.forEach(r=>i.insert(r)),i}_recomputeMaxUpperBound(e){var t,i;for(let{node:r}of this._traverseTo(e)){let n=r.value().upperBound;r.value().maxUpperBound=Math.max(n,((t=r.left())==null?void 0:t.value().maxUpperBound)??n,((i=r.right())==null?void 0:i.value().maxUpperBound)??n)}}*_traverseTo(e){let t=this._rangeMapper(e)[0];function*i(r,n){if(r===void 0)return;let o=r.value().lowerBound;if(r.value().data===e){yield{node:r,parent:n};return}t<o?yield*i(r.left(),r):yield*i(r.right(),r),yield{node:r,parent:n}}yield*i(this._tree.root(),void 0)}}class P{constructor(e,t,i,r){p(this,"data"),p(this,"lowerBound"),p(this,"upperBound"),p(this,"maxUpperBound"),this.data=r,this.lowerBound=e,this.upperBound=t,this.maxUpperBound=i}}function b(s){const[e,t]=s.split(" ");let[i,r]=e.split(":").map(Number);return t==="PM"&&i!==12&&(i+=12),t==="AM"&&i===12&&(i=0),i+r/60}function M(s,e){return s>=e&&(e+=24),[s,e]}function f(){return new m(s=>M(b(s.from),b(s.to)))}function R(s,e){return`${s},${e}`}function F(s){const e=[],t=new Set,i=Array.from(s.values()).filter(u=>u.isEnabled);if(!i.length)return e;const r={};for(const u of i)r[u.code]=Array.from(u.sections.values()).filter(a=>a.isEnabled);const n={};for(const u in r)for(const a of r[u]){const g=R(u,a.code);n[g]=Array.from(a.timeslots.values()).filter(h=>h.isEnabled)}const o={mon:f(),tue:f(),wed:f(),thu:f(),fri:f(),sat:f(),sun:f()};function l(u=[],a=0){if(a===i.length){e.push(u.slice());return}for(let g=a;g<i.length;g++){const h=i[g];if(t.has(h.code))continue;const E=r[h.code];if(E.length)for(const w of E){let L=!1;const j=n[R(h.code,w.code)];if(!j.length)continue;for(const c of j){let[_,Q]=M(b(c.from),b(c.to));if(o[c.day].hasOverlap(_,Q)){L=!0;break}}if(L)continue;u.push({subject:h,section:w}),t.add(h.code);let z=[];for(let[c,_]of w.timeslots)o[_.day].insert(_),z.push(_);l(u,a+1),u.pop(),t.delete(h.code);for(let c of z)o[c.day].delete(c)}}}return l(),e}function O(s){let e=new Map;for(let t of s){let i={code:t.c,isEnabled:t.e,description:t.d,sections:new Map};for(let r of t.s){let n={code:r.c,isEnabled:r.e,description:r.d,timeslots:new Map};for(let o of r.t){let l={day:o.d,from:o.f,to:o.t,id:o.i,isEnabled:o.e};n.timeslots.set(l.id,l)}i.sections.set(n.code,n)}e.set(i.code,i)}return e}self.onmessage=s=>{let e=O(s.data);const t=F(e);self.postMessage(t)}})();
